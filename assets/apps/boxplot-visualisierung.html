<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boxplot Builder - Schritt f√ºr Schritt</title>
    <style>
        :root {
            --primary: #3498db;
            --primary-dark: #2980b9;
            --secondary: #9b59b6;
            --accent: #2ecc71;
            --danger: #e74c3c;
            --bg-gradient: linear-gradient(135deg, #f5f7fa 0%, #e4e8ec 100%);
            --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-gradient);
            min-height: 100vh;
            padding: 20px;
            color: #2c3e50;
        }

        .container {
            width: 100%;
            max-width: 90%;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: var(--secondary);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
        }

        .btn-reset {
            background: var(--danger);
            color: white;
        }

        .btn-reset:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: var(--card-shadow);
            position: relative;
        }

        .section-title {
            font-size: 1.3rem;
            margin-bottom: 25px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .step-indicator {
            font-size: 0.9rem;
            background: #ecf0f1;
            padding: 4px 12px;
            border-radius: 20px;
            color: #7f8c8d;
        }

        /* Number Line and Dots */
        .plot-container {
            height: 400px;
            position: relative;
            margin: 20px 0;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px dashed #dee2e6;
            overflow: hidden;
        }

        .data-pool-zone {
            position: absolute;
            top: 20px;
            left: 5%;
            right: 5%;
            height: 150px;
            background: rgba(236, 240, 241, 0.5);
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            align-content: center;
            justify-content: center;
            padding: 10px;
            border: 2px dashed #bdc3c7;
        }

        .data-pool-label {
            position: absolute;
            top: -12px;
            left: 20px;
            background: #f8f9fa;
            padding: 0 10px;
            font-size: 0.8rem;
            color: #95a5a6;
            font-weight: bold;
        }

        .axis {
            position: absolute;
            bottom: 60px;
            left: 5%;
            right: 5%;
            height: 2px;
            background: #bdc3c7;
        }

        .axis-tick {
            position: absolute;
            top: 100%;
            width: 2px;
            height: 10px;
            background: #bdc3c7;
        }

        .axis-label {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            color: #7f8c8d;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            position: absolute;
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            bottom: 75px;
            transform: translateX(-50%);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            z-index: 10;
            opacity: 0.6;
        }

        .dot.active {
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
            transform: translateX(-50%) scale(1.3);
            z-index: 11;
        }

        .dot.quartile {
            background: var(--secondary);
            box-shadow: 0 0 10px var(--secondary);
        }

        .dot.outlier {
            background: #34495e;
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            transform: translateX(-50%) scale(1.7);
            opacity: 1;
            box-shadow: none;
        }

        /* Boxplot Elements */
        .boxplot-element {
            position: absolute;
            transition: all 0.5s ease;
            opacity: 0;
        }

        .boxplot-box {
            background: rgba(155, 89, 182, 0.15);
            border: 2px solid var(--secondary);
            height: 80px;
            bottom: 40px;
            z-index: 5;
        }

        .boxplot-median-line {
            width: 2px;
            height: 80px;
            background: var(--danger);
            bottom: 40px;
            z-index: 6;
            transform: translateX(-1px);
        }

        .boxplot-q-line {
            width: 2px;
            height: 80px;
            background: var(--secondary);
            bottom: 40px;
            z-index: 6;
            transform: translateX(-1px);
        }

        .boxplot-whisker {
            height: 2px;
            background: #7f8c8d;
            bottom: 80px;
            z-index: 4;
        }

        .boxplot-whisker-cap {
            width: 2px;
            height: 40px;
            background: #7f8c8d;
            bottom: 60px;
            z-index: 4;
            transform: translateX(-1px);
        }

        /* Info Display */
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #ddd;
        }

        .stat-card.median {
            border-left-color: var(--danger);
        }

        .stat-card.quartile {
            border-left-color: var(--secondary);
        }

        .stat-card.outlier {
            border-left-color: #34495e;
        }

        .stat-card h4 {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .stat-card .value {
            font-size: 1.4rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .explanation {
            background: #e8f4fd;
            border-left: 4px solid var(--primary);
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin-top: 30px;
        }

        .explanation h3 {
            margin-bottom: 10px;
            color: var(--primary-dark);
        }

        .explanation p {
            line-height: 1.6;
        }

        .highlight-text {
            font-weight: bold;
            color: var(--primary);
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .visible {
            opacity: 1 !important;
            animation: fadeIn 0.5s ease forwards;
        }

        @media (max-width: 768px) {
            .plot-container {
                height: 400px;
            }

            .dot {
                width: 10px;
                height: 10px;
            }

            .btn {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>üì¶ Boxplot Builder</h1>
            <p class="subtitle">Schrittweise Konstruktion eines Boxplots verstehen</p>
        </header>

        <div class="controls">
            <button class="btn btn-reset" id="resetBtn">Reset</button>
            <button class="btn btn-secondary" id="prevBtn" disabled>‚Üê Schritt zur√ºck</button>
            <button class="btn btn-primary" id="nextBtn" data-step="1">N√§chster Schritt: Sortieren ‚Üí</button>
        </div>

        <div class="visualization-area">
            <div class="section">
                <div class="section-title">
                    <span id="stepTitle">Rohdaten-Ansicht</span>
                    <span class="step-indicator" id="stepIndicator">Schritt 1 von 6</span>
                </div>

                <div class="plot-container" id="plotContainer">
                    <div class="data-pool-zone" id="dataPool">
                        <div class="data-pool-label">UNSORTIERTE ROHDATEN (POOL)</div>
                    </div>
                    <div class="axis" id="mainAxis"></div>
                    <!-- Dots and Boxplot elements will be injected here -->
                </div>

                <div class="info-panel" id="infoPanel">
                    <div class="stat-card">
                        <h4>Minimum</h4>
                        <div class="value" id="stat-min">-</div>
                    </div>
                    <div class="stat-card quartile">
                        <h4>Q1 (25% Quartil)</h4>
                        <div class="value" id="stat-q1">-</div>
                    </div>
                    <div class="stat-card median">
                        <h4>Median (50% Quartil)</h4>
                        <div class="value" id="stat-median">-</div>
                    </div>
                    <div class="stat-card quartile">
                        <h4>Q3 (75% Quartil)</h4>
                        <div class="value" id="stat-q3">-</div>
                    </div>
                    <div class="stat-card">
                        <h4>Maximum</h4>
                        <div class="value" id="stat-max">-</div>
                    </div>
                </div>

                <div class="explanation" id="explanationBox">
                    <h3 id="ex-title">Die Rohdaten</h3>
                    <p id="ex-text">Wir beginnen mit einer Menge von ungeordneten Datenpunkten auf einer Achse. In
                        diesem Zustand k√∂nnen wir die Verteilung nur schwer einsch√§tzen.</p>
                </div>
            </div>
        </div>
    </div>

    <footer style="text-align: center; margin-top: 30px; color: #95a5a6; font-size: 0.85rem; padding-bottom: 20px;">
        Erstellt mit Gemini 3 Flash und Antigravity. Von Manuel Hopp.
    </footer>

    <script>
        // CONFIGURATION
        const DATA_COUNT = 75; // More points
        const MIN_VAL = 140;
        const MAX_VAL = 210;

        // APP STATE
        let rawData = [];
        let sortedData = [];
        let currentStep = 0;
        let stats = {};

        const STEPS = [
            {
                title: "Rohdaten-Pool",
                btnText: "N√§chster Schritt: Auf Achse sortieren ‚Üí",
                exTitle: "Die Rohdaten",
                exText: "Hier siehst du die urspr√ºnglichen Werte (z.B. K√∂rpergr√∂√üe in cm). Sie liegen ungeordnet in einem 'Pool'."
            },
            {
                title: "Daten auf Achse sortieren",
                btnText: "N√§chster Schritt: Median finden ‚Üí",
                exTitle: "Sortierung nach Wert",
                exText: "Wir nehmen die Werte aus dem Pool und platzieren sie an ihrer korrekten Stelle auf der x-Achse."
            },
            {
                title: "Den Median finden",
                btnText: "N√§chster Schritt: Quartile finden ‚Üí",
                exTitle: "Der Median (Zentralwert)",
                exText: "Der Median teilt die sortierte Datenreihe genau in zwei H√§lften."
            },
            {
                title: "Quartile bestimmen",
                btnText: "N√§chster Schritt: Box zeichnen ‚Üí",
                exTitle: "Q1 und Q3 (Quartile)",
                exText: "Die Quartile teilen die Daten in Viertel. Sie bilden die Grenzen der sp√§teren Box."
            },
            {
                title: "Die Box zeichnen",
                btnText: "N√§chster Schritt: Whiskers hinzuf√ºgen ‚Üí",
                exTitle: "Zentraler Bereich",
                exText: "Die Box umschlie√üt die mittleren 50% der Daten (den Interquartilsabstand IQR)."
            },
            {
                title: "Whiskers (Schnurrhaare)",
                btnText: "N√§chster Schritt: Ausrei√üer pr√ºfen ‚Üí",
                exTitle: "Whiskers zeichnen",
                exText: "Die Whiskers reichen bis zum letzten Datenpunkt, der maximal das 1,5-fache des IQR von der Box entfernt ist."
            },
            {
                title: "Ausrei√üer identifizieren",
                btnText: "Fertig!",
                exTitle: "Ausrei√üer (Outliers)",
                exText: "Werte, die extrem weit au√üerhalb der Box liegen, werden als Ausrei√üer markiert (Sterne). Diese werden nicht mehr durch die Whiskers abgedeckt."
            }
        ];

        // DOM ELEMENTS
        const plotContainer = document.getElementById('plotContainer');
        const mainAxis = document.getElementById('mainAxis');
        const nextBtn = document.getElementById('nextBtn');
        const prevBtn = document.getElementById('prevBtn');
        const resetBtn = document.getElementById('resetBtn');
        const stepTitle = document.getElementById('stepTitle');
        const stepIndicator = document.getElementById('stepIndicator');
        const exTitle = document.getElementById('ex-title');
        const exText = document.getElementById('ex-text');

        // INITIALIZATION
        function init() {
            generateData();
            calculateStats();
            createAxisTicks();
            renderDots();
            currentStep = 0;
            updateUI();
        }

        function generateData() {
            rawData = [];
            // Generate normal-ish distributed data with some potential outliers
            const mean = 175;
            const std = 12;

            for (let i = 0; i < DATA_COUNT; i++) {
                // Pure Box-Muller for Normal Distribution
                const u1 = Math.random(), u2 = Math.random();
                const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                let val = mean + z * std;

                val = Math.round(Math.max(MIN_VAL, Math.min(MAX_VAL, val)));
                rawData.push({
                    value: val,
                    id: i,
                    initialX: 5 + Math.random() * 90,
                    initialY: 40 + Math.random() * 80,
                    jitter: (Math.random() - 0.5) * 40
                });
            }
            sortedData = [...rawData].sort((a, b) => a.value - b.value);

            // FORCE AT LEAST ONE OUTLIER
            calculateStats();
            const vals = sortedData.map(d => d.value);
            const hasOutliers = vals.some(v => v < stats.lowerFence || v > stats.upperFence);

            if (!hasOutliers) {
                // Replace strictly the most extreme value to preserve the "normal" look of the rest
                const indexToReplace = Math.random() > 0.5 ? 0 : DATA_COUNT - 1;
                const newValue = (indexToReplace === 0) ? Math.min(stats.lowerFence - 2, MIN_VAL + 5) : Math.max(stats.upperFence + 2, MAX_VAL - 5);

                const originalId = sortedData[indexToReplace].id;
                const rawIndex = rawData.findIndex(d => d.id === originalId);
                rawData[rawIndex].value = Math.round(newValue);

                sortedData = [...rawData].sort((a, b) => a.value - b.value);
                calculateStats();
            }
        }

        function calculateStats() {
            const vals = sortedData.map(d => d.value);
            const n = vals.length;

            const q2 = getMedian(vals);
            const lowerHalf = vals.slice(0, Math.floor(n / 2));
            const upperHalf = vals.slice(Math.ceil(n / 2));

            const q1 = getMedian(lowerHalf);
            const q3 = getMedian(upperHalf);
            const iqr = q3 - q1;

            const lowerFence = q1 - 1.5 * iqr;
            const upperFence = q3 + 1.5 * iqr;

            const minInside = Math.min(...vals.filter(v => v >= lowerFence));
            const maxInside = Math.max(...vals.filter(v => v <= upperFence));

            stats = { min: vals[0], max: vals[n - 1], q1, q2, q3, iqr, lowerFence, upperFence, minInside, maxInside };
        }

        function getMedian(arr) {
            const n = arr.length;
            if (n % 2 === 0) return (arr[n / 2 - 1] + arr[n / 2]) / 2;
            return arr[Math.floor(n / 2)];
        }

        function createAxisTicks() {
            mainAxis.innerHTML = '';
            for (let v = MIN_VAL; v <= MAX_VAL; v += 10) {
                const pct = ((v - MIN_VAL) / (MAX_VAL - MIN_VAL)) * 100;
                const tick = document.createElement('div');
                tick.className = 'axis-tick';
                tick.style.left = `${pct}%`;

                const label = document.createElement('div');
                label.className = 'axis-label';
                label.textContent = v;
                tick.appendChild(label);

                mainAxis.appendChild(tick);
            }
        }

        function renderDots() {
            // Clear but keep axis
            const oldDots = document.querySelectorAll('.dot, .boxplot-element');
            oldDots.forEach(d => d.remove());

            rawData.forEach(item => {
                const dot = document.createElement('div');
                dot.className = 'dot';
                dot.id = `dot-${item.id}`;
                dot.style.backgroundColor = getColorForValue(item.value);

                // Position will be set in updateUI
                plotContainer.appendChild(dot);
            });

            // Create boxplot elements (hidden initially)
            createBoxplotElements();
        }

        function createBoxplotElements() {
            const box = document.createElement('div');
            box.className = 'boxplot-element boxplot-box';
            box.id = 'bp-box';
            plotContainer.appendChild(box);

            const mLine = document.createElement('div');
            mLine.className = 'boxplot-element boxplot-median-line';
            mLine.id = 'bp-median';
            plotContainer.appendChild(mLine);

            const q1Line = document.createElement('div');
            q1Line.className = 'boxplot-element boxplot-q-line';
            q1Line.id = 'bp-q1';
            plotContainer.appendChild(q1Line);

            const q3Line = document.createElement('div');
            q3Line.className = 'boxplot-element boxplot-q-line';
            q3Line.id = 'bp-q3';
            plotContainer.appendChild(q3Line);

            const wLeft = document.createElement('div');
            wLeft.className = 'boxplot-element boxplot-whisker';
            wLeft.id = 'bp-whisker-left';
            plotContainer.appendChild(wLeft);

            const wRight = document.createElement('div');
            wRight.className = 'boxplot-element boxplot-whisker';
            wRight.id = 'bp-whisker-right';
            plotContainer.appendChild(wRight);

            const capLeft = document.createElement('div');
            capLeft.className = 'boxplot-element boxplot-whisker-cap';
            capLeft.id = 'bp-cap-left';
            plotContainer.appendChild(capLeft);

            const capRight = document.createElement('div');
            capRight.className = 'boxplot-element boxplot-whisker-cap';
            capRight.id = 'bp-cap-right';
            plotContainer.appendChild(capRight);
        }

        function updateUI() {
            const step = STEPS[currentStep];
            stepTitle.textContent = step.title;
            stepIndicator.textContent = `Schritt ${currentStep + 1} von ${STEPS.length}`;
            exTitle.textContent = step.exTitle;
            exText.textContent = step.exText;
            nextBtn.textContent = step.btnText;

            nextBtn.disabled = currentStep === STEPS.length - 1;
            prevBtn.disabled = currentStep === 0;

            // Update stats panel
            document.getElementById('stat-min').textContent = (currentStep >= 1) ? stats.min : "-";
            document.getElementById('stat-q1').textContent = (currentStep >= 3) ? stats.q1 : "-";
            document.getElementById('stat-median').textContent = (currentStep >= 2) ? stats.q2 : "-";
            document.getElementById('stat-q3').textContent = (currentStep >= 3) ? stats.q3 : "-";
            document.getElementById('stat-max').textContent = (currentStep >= 1) ? stats.max : "-";

            updatePositions();
        }

        function updatePositions() {
            const range = MAX_VAL - MIN_VAL;
            const containerWidth = plotContainer.offsetWidth * 0.9;
            const offset = plotContainer.offsetWidth * 0.05;

            rawData.forEach(item => {
                const dot = document.getElementById(`dot-${item.id}`);
                dot.classList.remove('median', 'quartile', 'outlier', 'active');

                let targetX, targetY;

                if (currentStep === 0) {
                    targetX = item.initialX;
                    targetY = 400 - item.initialY; // Place in the top pool zone (bottom-up coords)
                    dot.style.opacity = "0.8";
                } else {
                    const pct = (item.value - MIN_VAL) / range;
                    targetX = pct * 90 + 5; // 5% to 95%
                    targetY = 75 + item.jitter; // Apply jitter
                    dot.style.opacity = "0.6";

                    // Highlight based on step
                    if (currentStep >= 2 && item.value === stats.q2 && sortedData[Math.floor(DATA_COUNT / 2)].id === item.id) {
                        // Median dot is no longer specially styled or positioned
                    }
                    if (currentStep >= 6) {
                        if (item.value < stats.lowerFence || item.value > stats.upperFence) {
                            dot.classList.add('outlier');
                        }
                    }
                    if (currentStep === 5) {
                        // In final step, maybe dim non-outliers or move them into the box?
                        // Let's keep them on the line for clarity.
                    }
                }

                dot.style.left = `${targetX}%`;
                dot.style.bottom = `${targetY}px`;
            });

            // Update Boxplot Elements
            const box = document.getElementById('bp-box');
            const medianLine = document.getElementById('bp-median');
            const wLeft = document.getElementById('bp-whisker-left');
            const wRight = document.getElementById('bp-whisker-right');
            const cLeft = document.getElementById('bp-cap-left');
            const cRight = document.getElementById('bp-cap-right');

            const mPct = (stats.q2 - MIN_VAL) / range * 90 + 5;
            const q1Pct = (stats.q1 - MIN_VAL) / range * 90 + 5;
            const q3Pct = (stats.q3 - MIN_VAL) / range * 90 + 5;
            const minIPct = (stats.minInside - MIN_VAL) / range * 90 + 5;
            const maxIPct = (stats.maxInside - MIN_VAL) / range * 90 + 5;

            // Box
            box.style.left = `${q1Pct}%`;
            box.style.width = `${q3Pct - q1Pct}%`;
            box.style.opacity = (currentStep >= 4) ? 1 : 0;

            // Median Line
            medianLine.style.left = `${mPct}%`;
            medianLine.style.opacity = (currentStep >= 2) ? 1 : 0;

            // Q1 & Q3 Lines
            const q1Line = document.getElementById('bp-q1');
            const q3Line = document.getElementById('bp-q3');
            q1Line.style.left = `${q1Pct}%`;
            q3Line.style.left = `${q3Pct}%`;
            q1Line.style.opacity = (currentStep >= 3) ? 1 : 0;
            q3Line.style.opacity = (currentStep >= 3) ? 1 : 0;

            // Whiskers
            wLeft.style.left = `${minIPct}%`;
            wLeft.style.width = `${q1Pct - minIPct}%`;
            wLeft.style.opacity = (currentStep >= 5) ? 1 : 0;

            wRight.style.left = `${q3Pct}%`;
            wRight.style.width = `${maxIPct - q3Pct}%`;
            wRight.style.opacity = (currentStep >= 5) ? 1 : 0;

            // Caps
            cLeft.style.left = `${minIPct}%`;
            cLeft.style.opacity = (currentStep >= 5) ? 1 : 0;

            cRight.style.left = `${maxIPct}%`;
            cRight.style.opacity = (currentStep >= 5) ? 1 : 0;
        }

        function getColorForValue(val) {
            const normalized = (val - MIN_VAL) / (MAX_VAL - MIN_VAL);
            const hue = 220 - (normalized * 220);
            return `hsl(${hue}, 70%, 50%)`;
        }

        // EVENT LISTENERS
        nextBtn.addEventListener('click', () => {
            if (currentStep < STEPS.length - 1) {
                currentStep++;
                updateUI();
            }
        });

        prevBtn.addEventListener('click', () => {
            if (currentStep > 0) {
                currentStep--;
                updateUI();
            }
        });

        resetBtn.addEventListener('click', init);

        window.addEventListener('resize', updatePositions);

        // START
        init();
    </script>
</body>

</html>